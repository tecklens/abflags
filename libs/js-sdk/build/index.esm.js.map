{"version":3,"file":"index.esm.js","sources":["../../../node_modules/tiny-emitter/index.js","../src/types/state.ts","../../../node_modules/uuid/dist/esm-browser/rng.js","../../../node_modules/uuid/dist/esm-browser/stringify.js","../../../node_modules/uuid/dist/esm-browser/native.js","../../../node_modules/uuid/dist/esm-browser/v4.js","../src/lib/events-handler.ts","../src/storage/storage-provider-local.ts","../src/storage/storage-provider-inmemory.ts","../src/utils/index.ts","../src/lib/metrics.ts","../src/lib/ab-client.ts"],"sourcesContent":["function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\nmodule.exports.TinyEmitter = E;\n","export type SdkState = 'initializing' | 'error' | 'healthy';\r\n\r\nexport const HEADER_API_KEY = 'api_key'\r\nexport const HEADER_E_TAG = 'api_key'\r\nexport const SESSION_ID = 'session_id'\r\nexport const REFRESH_INTERVAL_INIT = 2000\r\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import { v4 as uuidv4 } from 'uuid';\r\nimport {AbContext} from \"../types\";\r\n\r\nclass EventsHandler {\r\n    private generateEventId() {\r\n        return uuidv4();\r\n    }\r\n\r\n    public createImpressionEvent(\r\n        context: AbContext,\r\n        enabled: boolean,\r\n        featureName: string,\r\n        eventType: string,\r\n        impressionData?: boolean,\r\n        variant?: string\r\n    ) {\r\n        const baseEvent = this.createBaseEvent(\r\n            context,\r\n            enabled,\r\n            featureName,\r\n            eventType,\r\n            impressionData\r\n        );\r\n\r\n        if (variant) {\r\n            return {\r\n                ...baseEvent,\r\n                variant,\r\n            };\r\n        }\r\n        return baseEvent;\r\n    }\r\n\r\n    private createBaseEvent(\r\n        context: AbContext,\r\n        enabled: boolean,\r\n        featureName: string,\r\n        eventType: string,\r\n        impressionData?: boolean\r\n    ) {\r\n        return {\r\n            eventType,\r\n            eventId: this.generateEventId(),\r\n            context,\r\n            enabled,\r\n            featureName,\r\n            impressionData,\r\n        };\r\n    }\r\n}\r\n\r\nexport default EventsHandler;\r\n","import {IStorageProvider} from \"./storage-provider\";\r\n\r\nexport class LocalStorageProvider implements IStorageProvider {\r\n  private readonly prefix: string;\r\n\r\n  constructor(name = 'ab:cache') {\r\n    this.prefix = name;\r\n  }\r\n\r\n  public async save(name: string, data: any) {\r\n    const repo = JSON.stringify(data);\r\n    const key = `${this.prefix}:${name}`;\r\n    try {\r\n      window.localStorage.setItem(key, repo);\r\n    } catch (ex) {\r\n      console.error(ex);\r\n    }\r\n  }\r\n\r\n  public get(name: string) {\r\n    try {\r\n      const key = `${this.prefix}:${name}`;\r\n      const data = window.localStorage.getItem(key);\r\n      return data ? JSON.parse(data) : undefined;\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  }\r\n}\r\n","import {IStorageProvider} from './storage-provider';\r\n\r\nexport class InMemoryStorageProvider implements IStorageProvider {\r\n  private store = new Map();\r\n\r\n  public async save(name: string, data: any) {\r\n    this.store.set(name, data);\r\n  }\r\n\r\n  public async get(name: string) {\r\n    return this.store.get(name);\r\n  }\r\n}\r\n","import {AbContext} from \"../types\";\r\n\r\nexport const EVENTS = {\r\n  INIT: 'initialized',\r\n  ERROR: 'error',\r\n  READY: 'ready',\r\n  UPDATE: 'update',\r\n  IMPRESSION: 'impression',\r\n  SENT: 'sent',\r\n  RECOVERED: 'recovered',\r\n};\r\n\r\nexport const notNullOrUndefined = ([, value]: [string, string]) =>\r\n  value !== undefined && value !== null;\r\n\r\nexport const contextString = (context: AbContext): string => {\r\n\r\n  return JSON.stringify(context);\r\n};\r\n\r\nconst sha256 = async (input: string): Promise<string> => {\r\n  const cryptoSubtle =\r\n    typeof globalThis !== 'undefined' && globalThis.crypto?.subtle\r\n      ? globalThis.crypto?.subtle\r\n      : undefined;\r\n\r\n  if (\r\n    typeof TextEncoder === 'undefined' ||\r\n    !cryptoSubtle?.digest ||\r\n    typeof Uint8Array === 'undefined'\r\n  ) {\r\n    throw new Error('Hashing function not available');\r\n  }\r\n\r\n  const msgUint8 = new TextEncoder().encode(input);\r\n  const hashBuffer = await cryptoSubtle.digest('SHA-256', msgUint8);\r\n  return Array.from(new Uint8Array(hashBuffer))\r\n    .map((x) => x.toString(16).padStart(2, '0'))\r\n    .join('');\r\n};\r\nexport const computeContextHashValue = async (obj: AbContext) => {\r\n  const value = contextString(obj);\r\n\r\n  try {\r\n    return await sha256(value);\r\n  } catch {\r\n    return value;\r\n  }\r\n};\r\n\r\nexport const resolveFetch = () => {\r\n  try {\r\n    if (typeof window !== 'undefined' && 'fetch' in window) {\r\n      return window.fetch.bind(window);\r\n    }\r\n\r\n    if ('fetch' in globalThis) {\r\n      return globalThis.fetch.bind(globalThis);\r\n    }\r\n  } catch (e) {\r\n    console.error('Unleash failed to resolve \"fetch\"', e);\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\nexport const resolveAbortController = () => {\r\n  try {\r\n    if (typeof window !== 'undefined' && 'AbortController' in window) {\r\n      return new window.AbortController();\r\n    }\r\n\r\n    if ('fetch' in globalThis) {\r\n      return new globalThis.AbortController();\r\n    }\r\n  } catch (e) {\r\n    console.error('Unleash failed to resolve \"AbortController\" factory', e);\r\n  }\r\n};\r\n","import {notNullOrUndefined} from \"../utils\";\r\nimport {HEADER_API_KEY} from \"../types\";\r\n\r\nexport interface MetricsOptions {\r\n  onError: OnError;\r\n  onSent?: OnSent;\r\n  appName: string;\r\n  metricsInterval?: number;\r\n  disableMetrics?: boolean;\r\n  url: URL | string;\r\n  clientKey: string;\r\n  fetch: any;\r\n  customHeaders?: Record<string, string>;\r\n  metricsIntervalInitial?: number;\r\n}\r\n\r\ninterface Bucket {\r\n  start: Date;\r\n  stop: Date | null;\r\n  features: {\r\n    [s: string]: { yes: number; no: number; };\r\n  };\r\n}\r\n\r\ninterface Payload {\r\n  bucket: Bucket;\r\n  appName: string;\r\n  instanceId: string;\r\n  createdAt: Date;\r\n}\r\n\r\ntype OnError = (error: unknown) => void;\r\ntype OnSent = (payload: Payload) => void;\r\n// eslint-disable-next-line @typescript-eslint/no-empty-function\r\nconst doNothing = () => {};\r\n\r\nexport class Metrics {\r\n  private readonly onError: OnError;\r\n  private readonly onSent: OnSent;\r\n  private bucket: Bucket;\r\n  private readonly appName: string;\r\n  private readonly metricsInterval?: number;\r\n  private readonly disabled: boolean;\r\n  private readonly url: URL;\r\n  private readonly clientKey: string;\r\n  private timer: any;\r\n  private readonly fetch: any;\r\n  private customHeaders: Record<string, string>;\r\n  private readonly metricsIntervalInitial?: number;\r\n\r\n  constructor({\r\n                onError,\r\n                onSent,\r\n                appName,\r\n                metricsInterval,\r\n                disableMetrics = false,\r\n                url,\r\n                clientKey,\r\n                fetch,\r\n                customHeaders = {},\r\n                metricsIntervalInitial,\r\n              }: MetricsOptions) {\r\n    this.onError = onError;\r\n    this.onSent = onSent || doNothing;\r\n    this.disabled = disableMetrics;\r\n    this.metricsInterval = metricsInterval ??  1000;\r\n    this.metricsIntervalInitial = metricsIntervalInitial ?? 1000;\r\n    this.appName = appName;\r\n    this.url = url instanceof URL ? url : new URL(url);\r\n    this.clientKey = clientKey;\r\n    this.bucket = this.createEmptyBucket();\r\n    this.fetch = fetch;\r\n    this.customHeaders = customHeaders;\r\n  }\r\n\r\n  public start() {\r\n    if (this.disabled) {\r\n      return false;\r\n    }\r\n\r\n    if (\r\n      typeof this.metricsInterval === 'number' &&\r\n      this.metricsInterval > 0\r\n    ) {\r\n      if (this.metricsIntervalInitial && this.metricsIntervalInitial > 0) {\r\n        setTimeout(async () => {\r\n          this.startTimer();\r\n          await this.sendMetrics();\r\n        }, this.metricsIntervalInitial);\r\n      } else {\r\n        this.startTimer();\r\n      }\r\n    }\r\n  }\r\n\r\n  public stop() {\r\n    if (this.timer) {\r\n      clearTimeout(this.timer);\r\n      delete this.timer;\r\n    }\r\n  }\r\n\r\n  public createEmptyBucket(): Bucket {\r\n    return {\r\n      start: new Date(),\r\n      stop: null,\r\n      features: {},\r\n    };\r\n  }\r\n\r\n  private getHeaders() {\r\n    const headers: Record<string, string> = {\r\n      [HEADER_API_KEY]: this.clientKey,\r\n      'Accept': 'application/json',\r\n      'Content-Type': 'application/json',\r\n    };\r\n\r\n    Object.entries(this.customHeaders)\r\n      .filter(notNullOrUndefined)\r\n      .forEach(([name, value]) => (headers[name] = value));\r\n\r\n    return headers;\r\n  }\r\n\r\n  public async sendMetrics(): Promise<void> {\r\n    /* istanbul ignore next if */\r\n\r\n    const url = `${this.url}ab/v1/metric`;\r\n    const payload = this.getPayload();\r\n\r\n    if (this.bucketIsEmpty(payload)) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await this.fetch(url, {\r\n        cache: 'no-cache',\r\n        method: 'POST',\r\n        headers: this.getHeaders(),\r\n        body: JSON.stringify(payload),\r\n      });\r\n      this.onSent(payload);\r\n    } catch (e) {\r\n      console.error('AbFlags: unable to send feature metrics', e);\r\n      this.onError(e);\r\n    }\r\n  }\r\n\r\n  public count(name: string, enabled: boolean): boolean {\r\n    if (this.disabled || !this.bucket) {\r\n      return false;\r\n    }\r\n    this.assertBucket(name);\r\n    this.bucket.features[name][enabled ? 'yes' : 'no']++;\r\n    return true;\r\n  }\r\n\r\n  private assertBucket(name: string) {\r\n    if (this.disabled || !this.bucket) {\r\n      return false;\r\n    }\r\n    if (!this.bucket.features[name]) {\r\n      this.bucket.features[name] = {\r\n        yes: 0,\r\n        no: 0,\r\n      };\r\n    }\r\n  }\r\n\r\n  private startTimer(): void {\r\n    this.timer = setInterval(async () => {\r\n      await this.sendMetrics();\r\n    }, this.metricsInterval);\r\n  }\r\n\r\n  private bucketIsEmpty(payload: Payload) {\r\n    return Object.keys(payload.bucket.features).length === 0;\r\n  }\r\n\r\n  private getPayload(): Payload {\r\n    const bucket = { ...this.bucket, stop: new Date() };\r\n    console.debug(`send metric ${bucket}`)\r\n    this.bucket = this.createEmptyBucket();\r\n\r\n    return {\r\n      bucket,\r\n      createdAt: new Date(),\r\n      appName: this.appName,\r\n      instanceId: 'browser',\r\n    };\r\n  }\r\n}\r\n","import {TinyEmitter} from \"tiny-emitter\";\r\nimport {Feature, HEADER_API_KEY, IConfig, LastUpdateTerms, REFRESH_INTERVAL_INIT, SdkState, SESSION_ID} from \"../types\";\r\nimport EventsHandler from \"./events-handler\";\r\nimport {InMemoryStorageProvider, IStorageProvider, LocalStorageProvider} from \"../storage\";\r\nimport {computeContextHashValue, EVENTS, notNullOrUndefined, resolveAbortController, resolveFetch} from \"../utils\";\r\nimport {Metrics} from \"./metrics\";\r\n\r\nexport class AbClient extends TinyEmitter {\r\n  private _config: IConfig;\r\n  private eventsHandler: EventsHandler;\r\n  private readonly url: string;\r\n  private storage: IStorageProvider;\r\n  private state: SdkState;\r\n  private metrics: Metrics;\r\n  private readyEventEmitted = false;\r\n  private readonly storeKey = 'feature';\r\n  private readonly lastUpdateKey = 'last-time';\r\n  private lastRefreshTimestamp: number;\r\n  private features?: Feature[];\r\n  private readonly fetch: any;\r\n  private etag: string = '';\r\n  private abortController?: AbortController | null;\r\n  private lastError: any;\r\n  private fetchedFromServer = false;\r\n  private readonly ready: Promise<void>;\r\n  private started = false;\r\n  private timerRef?: any;\r\n\r\n  constructor(config: IConfig) {\r\n    super();\r\n\r\n    if (!config.clientKey) {\r\n      throw new Error('clientKey is required');\r\n    }\r\n    if (!config.appName) {\r\n      throw new Error('appName is required.');\r\n    }\r\n\r\n    this.eventsHandler = new EventsHandler();\r\n\r\n    this.url = config.url ?? 'https://ab.wolfx.app';\r\n\r\n    // * init storage\r\n    this.storage =\r\n      config.storageProvider ||\r\n      (typeof window !== 'undefined'\r\n        ? new LocalStorageProvider()\r\n        : new InMemoryStorageProvider());\r\n    this.fetch = resolveFetch()\r\n    if (!this.fetch) {\r\n      console.error(\r\n        'You must either provide your own \"fetch\" implementation or run in an environment where \"fetch\" is available.'\r\n      );\r\n    }\r\n\r\n    this._config = config;\r\n    this.ready = new Promise((resolve) => {\r\n      this.init()\r\n        .then(resolve)\r\n        .catch((error) => {\r\n          console.debug(error);\r\n          this.state = 'error';\r\n          this.emit(EVENTS.ERROR, error);\r\n          this.lastError = error;\r\n          resolve();\r\n        });\r\n    });\r\n    this.features = [];\r\n    this.lastRefreshTimestamp = 0;\r\n    this.state = 'initializing';\r\n\r\n    this.metrics = new Metrics({\r\n      onError: this.emit.bind(this, EVENTS.ERROR),\r\n      onSent: this.emit.bind(this, EVENTS.SENT),\r\n      appName: this._config.appName,\r\n      metricsInterval: this._config.metricsInterval,\r\n      disableMetrics: this._config.disableMetrics ?? false,\r\n      url: this.url,\r\n      clientKey: this._config.clientKey,\r\n      fetch: this.fetch,\r\n      customHeaders: this._config.customHeaders,\r\n      metricsIntervalInitial: this._config.metricsIntervalInitial ?? 10,\r\n    });\r\n  }\r\n\r\n  private async init(): Promise<void> {\r\n    this._config.sessionId = await this.resolveSessionId();\r\n\r\n    this.features = (await this.storage.get(this.storeKey)) || [];\r\n    this.lastRefreshTimestamp = await this.getLastRefreshTimestamp();\r\n\r\n    this.state = 'healthy';\r\n    this.emit(EVENTS.INIT);\r\n  }\r\n\r\n  public async start(): Promise<void> {\r\n    this.started = true;\r\n    if (this.timerRef) {\r\n      console.error(\r\n        'SDK has already started, if you want to restart the SDK you should call client.stop() before starting again.'\r\n      );\r\n      return;\r\n    }\r\n    await this.ready;\r\n    this.metrics.start();\r\n    const interval = this._config.refreshInterval && this._config.refreshInterval > 500 ? this._config.refreshInterval : REFRESH_INTERVAL_INIT;\r\n\r\n    await this.initialFetchFeatures();\r\n\r\n    if (interval > 0) {\r\n      this.timerRef = setInterval(() => this.fetchFeatures(), interval);\r\n    }\r\n  }\r\n\r\n  private async getLastRefreshTimestamp(): Promise<number> {\r\n    const lastRefresh: LastUpdateTerms | undefined =\r\n      await this.storage.get(this.lastUpdateKey);\r\n    const contextHash = await computeContextHashValue({\r\n      appName: this._config.appName,\r\n      sessionId: this._config.sessionId,\r\n      currentTime: this._config.currentTime,\r\n      userId: this._config.userId,\r\n      environment: this._config.environment,\r\n      properties: this._config.properties,\r\n    });\r\n    return lastRefresh?.key === contextHash ? lastRefresh.timestamp : 0;\r\n  }\r\n\r\n  private setReady() {\r\n    this.readyEventEmitted = true;\r\n    this.emit(EVENTS.READY);\r\n  }\r\n\r\n  private async storeLastRefreshTimestamp(): Promise<void> {\r\n    this.lastRefreshTimestamp = Date.now();\r\n\r\n    const contextHash = await computeContextHashValue({\r\n      appName: this._config.appName,\r\n      sessionId: this._config.sessionId,\r\n      currentTime: this._config.currentTime,\r\n      userId: this._config.userId,\r\n      environment: this._config.environment,\r\n      properties: this._config.properties,\r\n    });\r\n    const lastUpdateValue: LastUpdateTerms = {\r\n      key: contextHash,\r\n      timestamp: this.lastRefreshTimestamp,\r\n    };\r\n    await this.storage.save(this.lastUpdateKey, lastUpdateValue);\r\n  }\r\n\r\n  private async resolveSessionId(): Promise<string> {\r\n    let sessionId = await this.storage.get(SESSION_ID);\r\n    if (!sessionId) {\r\n      sessionId = Math.floor(Math.random() * 1_000_000_000);\r\n      await this.storage.save(SESSION_ID, sessionId.toString(10));\r\n    }\r\n    return sessionId.toString(10);\r\n  }\r\n\r\n  private isUpToDate(): boolean {\r\n    const now = Date.now();\r\n\r\n    const ttl = this._config.refreshInterval && this._config.refreshInterval > 500 ? this._config.refreshInterval : REFRESH_INTERVAL_INIT;\r\n\r\n    return (\r\n      this.lastRefreshTimestamp > 0 &&\r\n      this.lastRefreshTimestamp <= now &&\r\n      now - this.lastRefreshTimestamp <= ttl\r\n    );\r\n  }\r\n\r\n  private initialFetchFeatures() {\r\n    if (this.isUpToDate()) {\r\n      if (!this.fetchedFromServer) {\r\n        this.fetchedFromServer = true;\r\n        this.setReady();\r\n      }\r\n      return;\r\n    }\r\n    return this.fetchFeatures();\r\n  }\r\n\r\n  private async fetchFeatures() {\r\n    if (this.fetch) {\r\n      if (this.abortController) {\r\n        this.abortController.abort();\r\n      }\r\n      this.abortController = resolveAbortController();\r\n      const signal = this.abortController\r\n        ? this.abortController.signal\r\n        : undefined;\r\n      try {\r\n        const url = new URL('/ab/v1/feature/frontend', this.url);\r\n        const method = 'GET';\r\n        url.searchParams.set('appName', this._config.appName)\r\n        url.searchParams.set('environment', this._config.environment ?? '')\r\n        url.searchParams.set('userId', this._config.userId ?? '')\r\n        url.searchParams.set('sessionId', this._config.sessionId ?? '')\r\n        url.searchParams.set('currentTime', this._config.currentTime ?? new Date().toString())\r\n        for (let entry of Object.entries(this._config.properties ?? {})) {\r\n          url.searchParams.set(entry[0], entry[1])\r\n        }\r\n\r\n        const response = await this.fetch(url.toString(), {\r\n          method,\r\n          cache: 'no-cache',\r\n          headers: this.getHeaders(),\r\n          signal,\r\n        });\r\n        if (this.state === 'error' && response.status < 400) {\r\n          this.state = 'healthy';\r\n          this.emit(EVENTS.RECOVERED);\r\n        }\r\n\r\n        if (response.ok) {\r\n          this.etag = response.headers.get('ETag') || '';\r\n          const data = await response.json();\r\n\r\n          await this.storeFeatures(data);\r\n\r\n          if (this.state !== 'healthy') {\r\n            this.state = 'healthy';\r\n          }\r\n          if (!this.fetchedFromServer) {\r\n            this.fetchedFromServer = true;\r\n            this.setReady();\r\n          }\r\n          this.storeLastRefreshTimestamp();\r\n        } else if (response.status === 304) {\r\n          this.storeLastRefreshTimestamp();\r\n        } else {\r\n          console.error(\r\n            'AbFlags: Fetching feature toggles did not have an ok response'\r\n          );\r\n          this.state = 'error';\r\n          this.emit(EVENTS.ERROR, {\r\n            type: 'HttpError',\r\n            code: response.status,\r\n          });\r\n\r\n          this.lastError = {\r\n            type: 'HttpError',\r\n            code: response.status,\r\n          };\r\n        }\r\n      } catch (e) {\r\n        if (\r\n          !(\r\n            typeof e === 'object' &&\r\n            e !== null &&\r\n            'name' in e &&\r\n            e.name === 'AbortError'\r\n          )\r\n        ) {\r\n          console.error(\r\n            'AbFlags: unable to fetch feature toggles',\r\n            e\r\n          );\r\n          this.state = 'error';\r\n          this.emit(EVENTS.ERROR, e);\r\n          this.lastError = e;\r\n        }\r\n      } finally {\r\n        this.abortController = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  private async storeFeatures(features: Feature[]): Promise<void> {\r\n    this.features = features;\r\n    this.emit(EVENTS.UPDATE);\r\n    await this.storage.save(this.storeKey, features);\r\n  }\r\n\r\n  private getHeaders() {\r\n    const headers: Record<string, string> = {\r\n      [HEADER_API_KEY]: this._config.clientKey,\r\n      Accept: 'application/json',\r\n    };\r\n    headers['Content-Type'] = 'application/json';\r\n    if (this.etag) {\r\n      headers['If-None-Match'] = this.etag;\r\n    }\r\n    Object.entries(this._config.customHeaders ?? {})\r\n      .filter(notNullOrUndefined)\r\n      .forEach(([name, value]) => (headers[name] = value));\r\n    return headers;\r\n  }\r\n\r\n  isEnabled(key: string) {\r\n    const enabled = !!this.features?.find(f => f.name === key)\r\n\r\n    this.metrics.count(key, enabled);\r\n\r\n    return enabled;\r\n  }\r\n}\r\n"],"names":["E","name","callback","ctx","e","self","listener","data","evtArr","len","evts","liveEvents","i","tinyEmitterModule","TinyEmitter","HEADER_API_KEY","SESSION_ID","REFRESH_INTERVAL_INIT","getRandomValues","rnds8","rng","byteToHex","unsafeStringify","arr","offset","randomUUID","native","v4","options","buf","rnds","EventsHandler","uuidv4","context","enabled","featureName","eventType","impressionData","variant","baseEvent","LocalStorageProvider","repo","key","ex","InMemoryStorageProvider","EVENTS","notNullOrUndefined","value","contextString","sha256","input","cryptoSubtle","_a","_b","msgUint8","hashBuffer","x","computeContextHashValue","obj","resolveFetch","resolveAbortController","doNothing","Metrics","onError","onSent","appName","metricsInterval","disableMetrics","url","clientKey","fetch","customHeaders","metricsIntervalInitial","headers","payload","bucket","AbClient","config","resolve","error","interval","lastRefresh","contextHash","lastUpdateValue","sessionId","now","ttl","signal","method","entry","response","features","f"],"mappings":"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","x_google_ignoreList":[0,2,3,4,5]}